# Docker 大纲

Docker 是一个容器化平台，通过镜像与容器实现“一次构建，随处运行”。核心由客户端与守护进程组成，利用 Linux 内核特性（Namespaces、cgroups、UnionFS/OverlayFS）提供进程隔离与资源限制。

---

## 1. 核心组成与概念
- 组件：`Client`（CLI）、`Daemon`（dockerd）、`Image`（镜像）、`Container`（容器）、`Registry`（仓库，如 Docker Hub）、`Compose`（编排）、`BuildKit`（构建引擎）
- 镜像（Image）：只读的分层文件（layers），包含运行环境与应用；以 `repo/name:tag` 标识
- 容器（Container）：镜像的运行实例，附加可写层；生命周期可管理（启动/停止/删除）
- 分层（Layer）：镜像构建的缓存与复用基础；层顺序影响缓存命中
- 仓库（Registry）：镜像存储与分发服务；公共（Docker Hub）或私有（Harbor/registry:2）
- 仓库库（Repository）：在某个 registry 上的镜像库，保存同一镜像名的多个标签（tag）；格式 `<namespace>/<name>`，如 `library/nginx`、`myorg/myapp`
- 卷（Volume）：持久化数据；可命名卷或绑定宿主机目录
- 网络（Network）：容器网络拓扑（bridge/host/none，自定义网络）

命名与地址结构：
- 完整镜像地址：`<registry>/<namespace>/<repository>:<tag>`
- 省略默认：不写 `registry` 默认 `docker.io`，不写 `namespace` 默认 `library`（仅官方库）
- 示例：`docker.io/library/nginx:1.25`、`ghcr.io/myorg/myapp:prod`、`localhost:5000/myapp:1.0`

---

## 2. 运行时架构（简述）
- 客户端发起命令 → 守护进程执行 → 调用内核特性做隔离与限制
- Namespaces：`pid`、`net`、`mnt`、`ipc`、`uts` 提供隔离
- cgroups：内存、CPU、IO 等资源限制
- OverlayFS：分层文件系统，支撑镜像层与容器可写层

---

## 3. 常用命令速查（CLI）
- 版本与信息：
  - `docker version`、`docker info`
- 登录与镜像：
  - `docker login`、`docker pull repo/name:tag`、`docker push repo/name:tag`
  - `docker images`、`docker rmi image_id`
- 容器生命周期：
  - 运行：`docker run -d --name web -p 8080:80 nginx:alpine`
  - 查看：`docker ps -a`、日志：`docker logs -f web`、进入：`docker exec -it web /bin/sh`
  - 管理：`docker start/stop/restart web`、删除：`docker rm web`
- 文件与检查：
  - `docker cp web:/var/log/app.log .`、`docker inspect web`、`docker stats`
- 清理：
  - `docker system df`、`docker system prune -f`

---

## 4. Dockerfile 与镜像构建
示例（Node + 多阶段构建）：
```dockerfile
# syntax=docker/dockerfile:1.6
FROM node:20-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

FROM node:20-alpine AS runtime
WORKDIR /app
ENV NODE_ENV=production
COPY --from=build /app/dist ./dist
COPY --from=build /app/node_modules ./node_modules
EXPOSE 3000
CMD ["node", "dist/server.js"]
```
- 构建：`docker build -t repo/app:1.0 .`
- `.dockerignore`：避免无关文件进入构建上下文（如 `node_modules`、`.git`）
- 关键指令：`FROM`、`RUN`、`COPY`、`ADD`、`ENV`、`WORKDIR`、`EXPOSE`、`CMD`、`ENTRYPOINT`、`ARG`
- 缓存优化：把变动频率低的步骤（依赖安装）放前面，提升缓存命中率

指令中文注释（速查）：
- `FROM <image>` 指定基础镜像，后续构建都在其之上扩展。
- `WORKDIR <path>` 设置镜像内的工作目录，后续拷贝与命令在此执行。
- `COPY <host-path> <image-path>` 从宿主机复制文件到镜像中的指定路径。
- `RUN <command>` 在构建阶段执行命令（生成镜像层），非运行时。
- `ENV <name> <value>` 设置环境变量，容器运行时可读取使用。
- `EXPOSE <port-number>` 声明镜像希望暴露的端口（文档化用途，不实际开放端口）。
- `USER <user-or-uid>` 设置后续指令与容器默认执行的用户。
- `CMD ["<command>", "<arg1>"]` 设置容器启动时的默认命令（可被运行时覆盖）。

---

## 5. 存储与网络
- 卷（Volume）：
  - 命名卷：`docker volume create data_vol`、挂载：`-v data_vol:/var/lib/app`
  - 绑定挂载：`-v /host/data:/var/lib/app:rw`（宿主机目录）
  - 用途：数据库数据、上传文件、日志持久化
- 网络（Network）：
  - 端口映射：`-p 8080:80`（宿主机 8080 → 容器 80）
  - 自定义网络：`docker network create my_net`，容器互通：`--network my_net`
  - 网络模式：bridge（默认）、host（共享宿主机网络）、none（隔离）

---

## 6. Docker Compose（快速上手）
`compose.yaml` 示例：
```yaml
services:
  web:
    image: nginx:alpine
    ports:
      - "8080:80"
    volumes:
      - ./html:/usr/share/nginx/html:ro
    depends_on:
      - db

  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_PASSWORD: example
    volumes:
      - db_data:/var/lib/postgresql/data

volumes:
  db_data:
```
- 启动：`docker compose up -d`
- 查看：`docker compose ps`、日志：`docker compose logs -f`
- 停止与清理：`docker compose down`（加 `-v` 删除卷）

---

## 7. 私有仓库与镜像分发
- Docker Hub：公共镜像仓库，默认注册与拉取
- 私有 `registry:2`：
  - 运行：`docker run -d -p 5000:5000 --name registry registry:2`
  - 推送：`docker tag repo/app:1.0 localhost:5000/app:1.0` → `docker push localhost:5000/app:1.0`
- 守护进程配置（镜像加速/私有仓库）：`/etc/docker/daemon.json`
```json
{
  "registry-mirrors": ["https://mirror.cc"],
  "insecure-registries": ["http://localhost:5000"]
}
```
重启守护进程后生效（Linux）：`sudo systemctl restart docker`

---

## 8. 最佳实践（后端视角）
- 最小化基础镜像：优先 `alpine` 或 `distroless`（生产镜像尽量小）
- 非 root 运行：在镜像中创建应用用户，降低安全风险
- 多阶段构建：分离构建与运行层，避免把编译工具带进生产镜像
- 健康检查：`HEALTHCHECK CMD curl -f http://localhost:3000/health || exit 1`
- 资源限制：`--memory`、`--cpus` 控制容器资源占用，避免影响宿主机
- 只读根文件系统：`--read-only` 并把写入点映射到卷
- 配置外置：用环境变量与 `--env-file`，避免硬编码到镜像层
- 日志策略：`--log-driver` 与按需收集，避免容器内堆积日志

---

## 9. 安全与合规
- 漏洞扫描：在 CI 中接入镜像扫描（如 Trivy），及时修复 CVE
- 镜像签名与来源：使用可信来源，避免从未知镜像拉取
- 机密管理：使用环境变量注入或与 secret 管理集成，不把 secrets 写入镜像层
- rootless 模式：尽可能启用无特权运行，降低攻击面

---

## 10. 常见问题与排查
- 端口映射不生效：确认服务监听 `0.0.0.0`，检查 `-p` 与防火墙
- 权限问题：容器内非 root 时，卷目录需宿主机侧赋予可写权限
- 容器秒退：`CMD/ENTRYPOINT` 执行完毕即退出；用前台进程或合适的启动命令
- 时区与时间：安装 `tzdata` 或通过环境变量设置时区；容器与宿主机时间同步
- 磁盘膨胀：长时间日志与未清理层导致；定期 `prune`，合理日志输出

---

## 11. 参考与下一步
- 官方文档：https://docs.docker.com/
- 建议：把现有服务（如后端 API）容器化，编写 Dockerfile 并用 Compose 联动数据库与缓存；随后考虑 CI 构建与推送到私有仓库。