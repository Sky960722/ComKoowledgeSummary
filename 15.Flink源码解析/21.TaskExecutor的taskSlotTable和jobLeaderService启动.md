# `taskSlotTable`和`jobLeaderService`启动

## TaskSlotTable

- `TaskSlotTable` 是一个用于**管理 TaskExecutor 上 Slot 使用情况**的接口。它负责记录与管理已分配的 Slot 信息，包括 Slot 的分配、释放以及当前资源占用状态等。
- 实现类是 `TaskSlotTableImpl`
- 在 TaskExecutor 中，`TaskSlotTable` 主要承担以下职责：
  - 管理当前已使用的 TaskSlots；
  - 提供 Slot 报告（`SlotReport`）以供 ResourceManager 汇总掌握节点资源情况；
  - 支持 Slot 状态变更的操作接口，如分配与释放。

### start方法

- **`TimerService`**：专门用于**管理注册的超时 Slot**，负责定时检查并触发超时处理。它是一个通用的定时任务调度组件，管理所有已注册的超时槽位。
- **`DefaultTimerService`**：`TimerService` 的具体实现类，内部维护了定时器和任务队列，用于实际的超时检测与回调。
- **`TimeoutListener`**：负责处理 Slot 超时事件的监听接口。当某个 Slot 超时后，`TimerService` 会回调该接口通知处理。
- **`TaskSlotTableImpl`**：实现了 `TimeoutListener`，作为监听者来接收超时回调。它会根据 Slot 超时情况，执行具体的回收、释放逻辑。
- **`SlotActions`**：定义了对 Slot 状态的操作接口（如释放、标记空闲等），是执行具体 Slot 资源管理动作的抽象层。
- **`SlotActionsImpl`**：`SlotActions` 的实现类，负责执行实际的 Slot 回收与资源释放操作。

~~~java
@Override
    public void start(
            SlotActions initialSlotActions, ComponentMainThreadExecutor mainThreadExecutor) {
        Preconditions.checkState(
                state == State.CREATED,
                "The %s has to be just created before starting",
                TaskSlotTableImpl.class.getSimpleName());
        this.slotActions = Preconditions.checkNotNull(initialSlotActions);
        this.mainThreadExecutor = Preconditions.checkNotNull(mainThreadExecutor);
		
        timerService.start(this);

        state = State.RUNNING;
    }
~~~

- 这部分内容可以等讲解客户端提交任务并向 ResourceManager 申请资源时，再详细展开。到时可以顺着 `timerService` 这条线，结合 Slot 分配的流程，具体说明超时 Slot 是如何注册和回收的。

## `JobLeaderService`

- **JobLeaderService** 主要负责为 **TaskExecutor** 提供 **JobMaster** 的发现服务。
- 在这个过程中，需要注册一个监听器，用于感知新的 **JobMaster** 启动或变更。这个监听器就是 **initialJobLeaderListener**。
- 由于这部分与启动流程关系不大，等到**客户端向 ResourceManager 申请资源**、以及 TaskExecutor 与 JobMaster 建立联系的环节，再详细展开讲解。
