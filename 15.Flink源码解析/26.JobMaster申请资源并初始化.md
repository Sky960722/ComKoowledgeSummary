# JobMaster

- JobMaster 核心承载三大关键职能：
  - **资源协调**，作为作业与资源管理器的交互中枢，精准对接并申请任务所需资源；
  - **任务全链路管控**，覆盖作业拆分、任务部署、依赖调度及故障容错等全流程管理；
  - **作业生命周期维护**，从初始化到执行调控，再到完成后的资源回收，实现端到端的作业闭环管理。

## JobMaster主要成员及方法

- JobMaster 继承自 FencedRpcEndpoint 抽象类，并同时实现了 JobMasterGateway 与 JobMasterService 两个接口。
- 这一设计明确了其双重属性：一方面，作为继承自 FencedRpcEndpoint 的实现类，它具备 RPC 通信能力，是一个标准的 RPC 通信组件；另一方面，通过实现 JobMasterService 接口，它对外提供 JobMaster 核心服务。
- 其中，JobMasterGateway 作为网关接口，起到了统一抽象的作用 —— 它规范了上层调用与底层实例之间的交互方式，使外部对 JobMaster 的访问无需关注具体实现细节，只需通过网关接口即可完成对其功能的调用，从而实现了接口与实现的解耦。

~~~java
/** Default names for Flink's distributed components. */
    public static final String JOB_MANAGER_NAME = "jobmanager";

    // ------------------------------------------------------------------------

    private final JobMasterConfiguration jobMasterConfiguration;

    private final ResourceID resourceId;
	
	//通常一个jobGraph对应一个jobMaster
    private final JobGraph jobGraph;

    private final Time rpcTimeout;

    private final HighAvailabilityServices highAvailabilityServices;

    private final BlobWriter blobWriter;

    private final HeartbeatServices heartbeatServices;
	
    private final ScheduledExecutorService futureExecutor;

    private final Executor ioExecutor;

    private final OnCompletionActions jobCompletionActions;

    private final FatalErrorHandler fatalErrorHandler;

    private final ClassLoader userCodeLoader;

    private final SlotPoolService slotPoolService;

    private final long initializationTimestamp;

    private final boolean retrieveTaskManagerHostName;

    // --------- ResourceManager --------

    private final LeaderRetrievalService resourceManagerLeaderRetriever;

    // --------- TaskManagers --------
	//申请的资源id以及对应的taskmanager申请的资源详情
    private final Map<ResourceID, TaskManagerRegistration> registeredTaskManagers;

    private final ShuffleMaster<?> shuffleMaster;

    // --------- Scheduler --------
	//调度。底层通过他将jobGraph对应的executorGraph初始化，并部署

    private final SchedulerNG schedulerNG;

    private final JobManagerJobStatusListener jobStatusListener;

    private final JobManagerJobMetricGroup jobManagerJobMetricGroup;
~~~

## `startJobExecution`方法

- startJobExecution 是一个启动类。用于将jobMaster启动。

- ~~~java
  private void startJobExecution() throws Exception {
          validateRunsInMainThread();
  		
          JobShuffleContext context = new JobShuffleContextImpl(jobGraph.getJobID(), this);
          shuffleMaster.registerJob(context);
  		//这里开始提供jobMaster相关服务。包括初步和resourceManager交互。心跳等
          startJobMasterServices();
  
          log.info(
                  "Starting execution of job '{}' ({}) under job master id {}.",
                  jobGraph.getName(),
                  jobGraph.getJobID(),
                  getFencingToken());
  		//这里开始调度
          startScheduling();
      }
  
   private void startJobMasterServices() throws Exception {
          try {
              //心跳服务。jobMaster监控taskManager是否正常运行
              this.taskManagerHeartbeatManager = createTaskManagerHeartbeatManager(heartbeatServices);
              //resourceManager心跳服务。监控resourceManager是否正常运行
              this.resourceManagerHeartbeatManager =
                      createResourceManagerHeartbeatManager(heartbeatServices);
  			
              // 启动Slot资源池服务，标志着JobMaster负责的资源管理功能正式启用
  			// 考虑到JobMaster后续将支持主从节点架构，此处需通过 fencing token 与地址信息
  			// 确保Slot池仅接收当前Leader节点的消息指令
              // start the slot pool make sure the slot pool now accepts messages for this leader
              slotPoolService.start(getFencingToken(), getAddress(), getMainThreadExecutor());
  
              // job is ready to go, try to establish connection with resource manager
              //   - activate leader retrieval for the resource manager
              //   - on notification of the leader, the connection will be established and
              //     the slot pool will start requesting slots
              // 监听。一旦确认了resourceManager。就启动该方法。通常是 yarn模式或者k8s有具体实现
              resourceManagerLeaderRetriever.start(new ResourceManagerLeaderListener());
          } catch (Exception e) {
              handleStartJobMasterServicesError(e);
          }
      }
  
  private void startScheduling() {
      	//SchedulerNG 正式开始工作
          schedulerNG.startScheduling();
  }
  ~~~

## `DefaultScheduler`

- `DefaultScheduler` 继承自 `SchedulerBase` 并实现了 `SchedulerOperations` 接口。
- 在实际应用中，无论是自定义算子构成的作业，还是常规的 Flink 作业，其资源申请与任务调度逻辑通常都由 `DefaultScheduler` 负责执行。

~~~java
@Override
    public final void startScheduling() {
        mainThreadExecutor.assertRunningInMainThread();
        registerJobMetrics(
                jobManagerJobMetricGroup,
                executionGraph,
                this::getNumberOfRestarts,
                deploymentStateTimeMetrics,
                executionGraph::registerJobStatusListener,
                executionGraph.getStatusTimestamp(JobStatus.INITIALIZING),
                jobStatusMetricsSettings);
        operatorCoordinatorHandler.startAllOperatorCoordinators();
        startSchedulingInternal();
    }
~~~

